{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "predictive-form",
  "type": "registry:block",
  "title": "Predictive Form (Cobalt)",
  "description": "AI-powered form with field prediction, auto-completion, validation, and context-aware suggestions",
  "categories": [
    "cobalt",
    "execution",
    "forms",
    "ai"
  ],
  "registryDependencies": [
    "card",
    "input",
    "button",
    "label"
  ],
  "dependencies": [],
  "devDependencies": [],
  "files": [
    {
      "path": "src/blocks/cobalt/predictive-form.tsx",
      "type": "registry:component",
      "content": "\"use client\"\n\n/**\n * Predictive Form - Cobalt Kernel Component\n *\n * AI-powered form with autofill suggestions and validation.\n * Implements A01-CANONICAL.md §4 — \"Predict, don't ask\"\n *\n * Features:\n * - Smart field suggestions based on context\n * - Autofill from previous entries\n * - Real-time validation\n * - Confidence indicators\n * - One-click acceptance\n *\n * @example\n * ```tsx\n * import { PredictiveForm } from \"@workspace/design-system\"\n *\n * <PredictiveForm\n *   fields={formFields}\n *   predictions={aiPredictions}\n *   onSubmit={handleSubmit}\n *   onAcceptPrediction={(fieldId, value) => acceptValue(fieldId, value)}\n * />\n * ```\n */\n\nimport * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from \"@/components/card\"\nimport { Button } from \"@/components/button\"\nimport { Input } from \"@/components/input\"\nimport { Label } from \"@/components/label\"\nimport { Textarea } from \"@/components/textarea\"\nimport { Badge } from \"@/components/badge\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/select\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/tooltip\"\nimport { Progress } from \"@/components/progress\"\nimport {\n  Sparkles,\n  Check,\n  X,\n  AlertCircle,\n  Loader2,\n  Brain,\n  History,\n  Zap,\n  ChevronRight,\n} from \"lucide-react\"\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type FieldType = \"text\" | \"number\" | \"email\" | \"date\" | \"select\" | \"textarea\" | \"currency\"\n\nexport interface FieldOption {\n  value: string\n  label: string\n}\n\nexport interface FieldPrediction {\n  value: string\n  confidence: number // 0-100\n  source: \"ai\" | \"history\" | \"default\" | \"calculated\"\n  explanation?: string\n}\n\nexport interface FormField {\n  id: string\n  name: string\n  label: string\n  type: FieldType\n  placeholder?: string\n  required?: boolean\n  options?: FieldOption[] // For select fields\n  validation?: {\n    min?: number\n    max?: number\n    pattern?: string\n    message?: string\n  }\n  dependencies?: string[] // Field IDs this field depends on\n}\n\nexport interface PredictiveFormProps {\n  /** Form title */\n  title?: string\n  /** Form description */\n  description?: string\n  /** Form fields configuration */\n  fields: FormField[]\n  /** AI/historical predictions for each field */\n  predictions?: Record<string, FieldPrediction>\n  /** Current field values */\n  values?: Record<string, string>\n  /** Submit callback */\n  onSubmit?: (values: Record<string, string>) => Promise<void>\n  /** Accept prediction callback */\n  onAcceptPrediction?: (fieldId: string, value: string) => void\n  /** Reject prediction callback */\n  onRejectPrediction?: (fieldId: string) => void\n  /** Request new prediction callback */\n  onRequestPrediction?: (fieldId: string, context: Record<string, string>) => Promise<FieldPrediction | null>\n  /** Loading state */\n  isLoading?: boolean\n  /** Submit button text */\n  submitText?: string\n  /** Show confidence indicators */\n  showConfidence?: boolean\n  /** Auto-accept predictions above this confidence threshold */\n  autoAcceptThreshold?: number\n  /** Custom className */\n  className?: string\n}\n\n// ============================================================================\n// Helper Components\n// ============================================================================\n\nfunction ConfidenceBadge({ confidence, source }: { confidence: number; source: string }) {\n  const getColor = () => {\n    if (confidence >= 90) return \"bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300\"\n    if (confidence >= 70) return \"bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300\"\n    if (confidence >= 50) return \"bg-amber-100 text-amber-700 dark:bg-amber-900 dark:text-amber-300\"\n    return \"bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300\"\n  }\n\n  const getIcon = () => {\n    switch (source) {\n      case \"ai\":\n        return <Brain className=\"h-3 w-3\" />\n      case \"history\":\n        return <History className=\"h-3 w-3\" />\n      case \"calculated\":\n        return <Zap className=\"h-3 w-3\" />\n      default:\n        return <Sparkles className=\"h-3 w-3\" />\n    }\n  }\n\n  return (\n    <TooltipProvider>\n      <Tooltip>\n        <TooltipTrigger>\n          <span\n            className={cn(\n              \"inline-flex items-center gap-1 rounded-full px-2 py-0.5 text-xs font-medium\",\n              getColor()\n            )}\n          >\n            {getIcon()}\n            {confidence}%\n          </span>\n        </TooltipTrigger>\n        <TooltipContent>\n          <p>\n            {source === \"ai\" && \"AI-generated suggestion\"}\n            {source === \"history\" && \"Based on previous entries\"}\n            {source === \"calculated\" && \"Calculated from other fields\"}\n            {source === \"default\" && \"Default value\"}\n          </p>\n          <p className=\"text-xs text-muted-foreground\">Confidence: {confidence}%</p>\n        </TooltipContent>\n      </Tooltip>\n    </TooltipProvider>\n  )\n}\n\nfunction PredictionSuggestion({\n  prediction,\n  onAccept,\n  onReject,\n  showConfidence,\n}: {\n  prediction: FieldPrediction\n  onAccept: () => void\n  onReject: () => void\n  showConfidence: boolean\n}) {\n  return (\n    <div className=\"mt-1 flex items-center gap-2 rounded-md border border-primary/20 bg-primary/5 px-2 py-1.5\">\n      <Sparkles className=\"h-3 w-3 text-primary shrink-0\" />\n      <span className=\"flex-1 text-sm truncate\">{prediction.value}</span>\n      {showConfidence && (\n        <ConfidenceBadge confidence={prediction.confidence} source={prediction.source} />\n      )}\n      <div className=\"flex items-center gap-1 shrink-0\">\n        <Button\n          type=\"button\"\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"h-6 w-6 p-0 hover:bg-green-100 hover:text-green-700\"\n          onClick={onAccept}\n        >\n          <Check className=\"h-3 w-3\" />\n        </Button>\n        <Button\n          type=\"button\"\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"h-6 w-6 p-0 hover:bg-red-100 hover:text-red-700\"\n          onClick={onReject}\n        >\n          <X className=\"h-3 w-3\" />\n        </Button>\n      </div>\n    </div>\n  )\n}\n\n// ============================================================================\n// Field Renderers\n// ============================================================================\n\ninterface FieldRendererProps {\n  field: FormField\n  value: string\n  onChange: (value: string) => void\n  prediction?: FieldPrediction\n  onAcceptPrediction?: () => void\n  onRejectPrediction?: () => void\n  showConfidence: boolean\n  error?: string\n}\n\nfunction FieldRenderer({\n  field,\n  value,\n  onChange,\n  prediction,\n  onAcceptPrediction,\n  onRejectPrediction,\n  showConfidence,\n  error,\n}: FieldRendererProps) {\n  const showPrediction = prediction && !value && onAcceptPrediction && onRejectPrediction\n\n  const commonInputClass = cn(\n    \"transition-all\",\n    prediction && !value && \"border-primary/50 bg-primary/5\"\n  )\n\n  const renderInput = () => {\n    switch (field.type) {\n      case \"textarea\":\n        return (\n          <Textarea\n            id={field.id}\n            name={field.name}\n            placeholder={field.placeholder}\n            value={value}\n            onChange={(e) => onChange(e.target.value)}\n            className={commonInputClass}\n            rows={3}\n          />\n        )\n\n      case \"select\":\n        return (\n          <Select value={value} onValueChange={onChange}>\n            <SelectTrigger className={commonInputClass}>\n              <SelectValue placeholder={field.placeholder || \"Select...\"} />\n            </SelectTrigger>\n            <SelectContent>\n              {field.options?.map((option) => (\n                <SelectItem key={option.value} value={option.value}>\n                  {option.label}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        )\n\n      case \"currency\":\n        return (\n          <div className=\"relative\">\n            <span className=\"absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground\">\n              $\n            </span>\n            <Input\n              id={field.id}\n              name={field.name}\n              type=\"number\"\n              placeholder={field.placeholder}\n              value={value}\n              onChange={(e) => onChange(e.target.value)}\n              className={cn(commonInputClass, \"pl-7\")}\n              min={field.validation?.min}\n              max={field.validation?.max}\n              step=\"0.01\"\n            />\n          </div>\n        )\n\n      default:\n        return (\n          <Input\n            id={field.id}\n            name={field.name}\n            type={field.type}\n            placeholder={field.placeholder}\n            value={value}\n            onChange={(e) => onChange(e.target.value)}\n            className={commonInputClass}\n            min={field.validation?.min}\n            max={field.validation?.max}\n            pattern={field.validation?.pattern}\n          />\n        )\n    }\n  }\n\n  return (\n    <div className=\"space-y-1.5\">\n      <Label htmlFor={field.id} className=\"flex items-center gap-2\">\n        {field.label}\n        {field.required && <span className=\"text-destructive\">*</span>}\n        {prediction && value === prediction.value && (\n          <Badge variant=\"secondary\" className=\"text-xs\">\n            <Sparkles className=\"mr-1 h-3 w-3\" />\n            AI-filled\n          </Badge>\n        )}\n      </Label>\n      {renderInput()}\n      {showPrediction && (\n        <PredictionSuggestion\n          prediction={prediction}\n          onAccept={onAcceptPrediction}\n          onReject={onRejectPrediction}\n          showConfidence={showConfidence}\n        />\n      )}\n      {error && (\n        <p className=\"flex items-center gap-1 text-sm text-destructive\">\n          <AlertCircle className=\"h-3 w-3\" />\n          {error}\n        </p>\n      )}\n    </div>\n  )\n}\n\n// ============================================================================\n// Main Component\n// ============================================================================\n\nexport function PredictiveForm({\n  title,\n  description,\n  fields,\n  predictions = {},\n  values: initialValues = {},\n  onSubmit,\n  onAcceptPrediction,\n  onRejectPrediction,\n  onRequestPrediction,\n  isLoading = false,\n  submitText = \"Submit\",\n  showConfidence = true,\n  autoAcceptThreshold = 95,\n  className,\n}: PredictiveFormProps) {\n  const [values, setValues] = React.useState<Record<string, string>>(initialValues)\n  const [errors, setErrors] = React.useState<Record<string, string>>({})\n  const [dismissedPredictions, setDismissedPredictions] = React.useState<Set<string>>(new Set())\n  const [isSubmitting, setIsSubmitting] = React.useState(false)\n\n  // Auto-accept high-confidence predictions\n  React.useEffect(() => {\n    if (autoAcceptThreshold > 0) {\n      Object.entries(predictions).forEach(([fieldId, prediction]) => {\n        if (\n          prediction.confidence >= autoAcceptThreshold &&\n          !values[fieldId] &&\n          !dismissedPredictions.has(fieldId)\n        ) {\n          handleAcceptPrediction(fieldId, prediction.value)\n        }\n      })\n    }\n  }, [predictions, autoAcceptThreshold])\n\n  const handleChange = (fieldId: string, value: string) => {\n    setValues((prev) => ({ ...prev, [fieldId]: value }))\n    // Clear error when user starts typing\n    if (errors[fieldId]) {\n      setErrors((prev) => {\n        const next = { ...prev }\n        delete next[fieldId]\n        return next\n      })\n    }\n  }\n\n  const handleAcceptPrediction = (fieldId: string, value: string) => {\n    setValues((prev) => ({ ...prev, [fieldId]: value }))\n    onAcceptPrediction?.(fieldId, value)\n  }\n\n  const handleRejectPrediction = (fieldId: string) => {\n    setDismissedPredictions((prev) => new Set([...prev, fieldId]))\n    onRejectPrediction?.(fieldId)\n  }\n\n  const validate = (): boolean => {\n    const newErrors: Record<string, string> = {}\n\n    fields.forEach((field) => {\n      const value = values[field.id] || \"\"\n\n      if (field.required && !value.trim()) {\n        newErrors[field.id] = `${field.label} is required`\n        return\n      }\n\n      if (field.validation) {\n        if (field.type === \"number\" || field.type === \"currency\") {\n          const numValue = parseFloat(value)\n          if (field.validation.min !== undefined && numValue < field.validation.min) {\n            newErrors[field.id] = field.validation.message || `Minimum value is ${field.validation.min}`\n          }\n          if (field.validation.max !== undefined && numValue > field.validation.max) {\n            newErrors[field.id] = field.validation.message || `Maximum value is ${field.validation.max}`\n          }\n        }\n\n        if (field.validation.pattern) {\n          const regex = new RegExp(field.validation.pattern)\n          if (!regex.test(value)) {\n            newErrors[field.id] = field.validation.message || \"Invalid format\"\n          }\n        }\n      }\n    })\n\n    setErrors(newErrors)\n    return Object.keys(newErrors).length === 0\n  }\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n\n    if (!validate()) return\n\n    setIsSubmitting(true)\n    try {\n      await onSubmit?.(values)\n    } catch (error) {\n      console.error(\"Form submission error:\", error)\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  // Calculate overall prediction acceptance\n  const totalPredictions = Object.keys(predictions).length\n  const acceptedPredictions = Object.entries(predictions).filter(\n    ([fieldId, pred]) => values[fieldId] === pred.value\n  ).length\n  const predictionProgress = totalPredictions > 0 ? (acceptedPredictions / totalPredictions) * 100 : 0\n\n  const formContent = (\n    <form onSubmit={handleSubmit} className=\"space-y-4\">\n      {/* Prediction Progress */}\n      {totalPredictions > 0 && (\n        <div className=\"rounded-lg bg-muted/50 p-3 space-y-2\">\n          <div className=\"flex items-center justify-between text-sm\">\n            <div className=\"flex items-center gap-2\">\n              <Brain className=\"h-4 w-4 text-primary\" />\n              <span className=\"font-medium\">AI Predictions</span>\n            </div>\n            <span className=\"text-muted-foreground\">\n              {acceptedPredictions}/{totalPredictions} accepted\n            </span>\n          </div>\n          <Progress value={predictionProgress} className=\"h-1.5\" />\n        </div>\n      )}\n\n      {/* Form Fields */}\n      <div className=\"grid gap-4 md:grid-cols-2\">\n        {fields.map((field) => {\n          const prediction = !dismissedPredictions.has(field.id) ? predictions[field.id] : undefined\n          return (\n            <div\n              key={field.id}\n              className={cn(field.type === \"textarea\" && \"md:col-span-2\")}\n            >\n              <FieldRenderer\n                field={field}\n                value={values[field.id] || \"\"}\n                onChange={(value) => handleChange(field.id, value)}\n                prediction={prediction}\n                onAcceptPrediction={() =>\n                  prediction && handleAcceptPrediction(field.id, prediction.value)\n                }\n                onRejectPrediction={() => handleRejectPrediction(field.id)}\n                showConfidence={showConfidence}\n                error={errors[field.id]}\n              />\n            </div>\n          )\n        })}\n      </div>\n\n      {/* Submit Button */}\n      <div className=\"flex justify-end gap-2 pt-4\">\n        {totalPredictions > acceptedPredictions && (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={() => {\n              Object.entries(predictions).forEach(([fieldId, pred]) => {\n                if (!values[fieldId] && !dismissedPredictions.has(fieldId)) {\n                  handleAcceptPrediction(fieldId, pred.value)\n                }\n              })\n            }}\n          >\n            <Sparkles className=\"mr-2 h-4 w-4\" />\n            Accept All Suggestions\n          </Button>\n        )}\n        <Button type=\"submit\" disabled={isSubmitting || isLoading}>\n          {isSubmitting ? (\n            <>\n              <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n              Processing...\n            </>\n          ) : (\n            <>\n              {submitText}\n              <ChevronRight className=\"ml-2 h-4 w-4\" />\n            </>\n          )}\n        </Button>\n      </div>\n    </form>\n  )\n\n  if (title || description) {\n    return (\n      <Card className={className}>\n        <CardHeader>\n          {title && (\n            <CardTitle className=\"flex items-center gap-2\">\n              <Sparkles className=\"h-5 w-5 text-primary\" />\n              {title}\n            </CardTitle>\n          )}\n          {description && <CardDescription>{description}</CardDescription>}\n        </CardHeader>\n        <CardContent>{formContent}</CardContent>\n      </Card>\n    )\n  }\n\n  return <div className={className}>{formContent}</div>\n}\n\n// ============================================================================\n// Preset Form Configurations\n// ============================================================================\n\nexport const INVOICE_FORM_FIELDS: FormField[] = [\n  { id: \"customer\", name: \"customer\", label: \"Customer\", type: \"select\", required: true, options: [] },\n  { id: \"invoice_date\", name: \"invoice_date\", label: \"Invoice Date\", type: \"date\", required: true },\n  { id: \"due_date\", name: \"due_date\", label: \"Due Date\", type: \"date\", required: true },\n  { id: \"po_number\", name: \"po_number\", label: \"PO Number\", type: \"text\" },\n  { id: \"amount\", name: \"amount\", label: \"Amount\", type: \"currency\", required: true },\n  { id: \"description\", name: \"description\", label: \"Description\", type: \"textarea\" },\n]\n\nexport const PURCHASE_ORDER_FIELDS: FormField[] = [\n  { id: \"supplier\", name: \"supplier\", label: \"Supplier\", type: \"select\", required: true, options: [] },\n  { id: \"order_date\", name: \"order_date\", label: \"Order Date\", type: \"date\", required: true },\n  { id: \"delivery_date\", name: \"delivery_date\", label: \"Expected Delivery\", type: \"date\" },\n  { id: \"ship_to\", name: \"ship_to\", label: \"Ship To\", type: \"select\", options: [] },\n  { id: \"total\", name: \"total\", label: \"Order Total\", type: \"currency\", required: true },\n  { id: \"notes\", name: \"notes\", label: \"Notes\", type: \"textarea\" },\n]\n\nexport const EXPENSE_FORM_FIELDS: FormField[] = [\n  { id: \"category\", name: \"category\", label: \"Category\", type: \"select\", required: true, options: [\n    { value: \"travel\", label: \"Travel\" },\n    { value: \"meals\", label: \"Meals & Entertainment\" },\n    { value: \"supplies\", label: \"Office Supplies\" },\n    { value: \"software\", label: \"Software & Subscriptions\" },\n    { value: \"other\", label: \"Other\" },\n  ]},\n  { id: \"date\", name: \"date\", label: \"Expense Date\", type: \"date\", required: true },\n  { id: \"amount\", name: \"amount\", label: \"Amount\", type: \"currency\", required: true },\n  { id: \"merchant\", name: \"merchant\", label: \"Merchant/Vendor\", type: \"text\" },\n  { id: \"description\", name: \"description\", label: \"Description\", type: \"textarea\", required: true },\n]\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport type { FieldType, FieldOption, FieldPrediction, FormField }\n"
    }
  ]
}