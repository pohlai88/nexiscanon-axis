#!/usr/bin/env tsx
/**
 * Generate Exports - Self-Verifying Exports Generator
 * 
 * Scans packages/design-system/src/components/ and automatically generates:
 * 1. package.json exports (subpath exports for tree-shaking)
 * 2. src/index.ts barrel file (optional, for convenience)
 * 
 * Run: pnpm gen:exports
 * CI: git diff --exit-code packages/design-system/package.json packages/design-system/src/index.ts
 */

import fs from 'fs';
import path from 'path';
import { glob } from 'glob';

const DS_ROOT = path.join(process.cwd(), 'packages/design-system');
const SRC_DIR = path.join(DS_ROOT, 'src');
const PACKAGE_JSON_PATH = path.join(DS_ROOT, 'package.json');
const INDEX_PATH = path.join(SRC_DIR, 'index.ts');

interface ComponentExport {
  name: string;          // button
  pascalName: string;    // Button
  filePath: string;      // ./src/components/button.tsx
  category: 'component' | 'hook' | 'lib' | 'provider' | 'token';
}

async function scanComponents(): Promise<ComponentExport[]> {
  const exports: ComponentExport[] = [];

  // Scan components
  const componentFiles = await glob('src/components/**/*.tsx', { cwd: DS_ROOT });
  for (const file of componentFiles) {
    const name = path.basename(file, '.tsx');
    exports.push({
      name,
      pascalName: toPascalCase(name),
      filePath: `./${file}`,
      category: 'component'
    });
  }

  // Scan hooks
  const hookFiles = await glob('src/hooks/**/*.ts', { cwd: DS_ROOT });
  for (const file of hookFiles) {
    const name = path.basename(file, '.ts');
    exports.push({
      name,
      pascalName: toPascalCase(name),
      filePath: `./${file}`,
      category: 'hook'
    });
  }

  // Scan lib utilities
  const libFiles = await glob('src/lib/**/*.ts', { cwd: DS_ROOT });
  for (const file of libFiles) {
    const name = path.basename(file, '.ts');
    exports.push({
      name,
      pascalName: toPascalCase(name),
      filePath: `./${file}`,
      category: 'lib'
    });
  }

  // Scan tokens
  const tokenFiles = await glob('src/tokens/**/*.ts', { cwd: DS_ROOT });
  for (const file of tokenFiles) {
    const name = path.basename(file, '.ts');
    exports.push({
      name,
      pascalName: toPascalCase(name),
      filePath: `./${file}`,
      category: 'token'
    });
  }

  return exports;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function generatePackageJsonExports(components: ComponentExport[]): Record<string, string> {
  const exports: Record<string, string> = {
    '.': './src/index.ts',
    './styles/globals.css': './src/styles/globals.css',
    './providers': './src/providers/index.ts',
  };

  // Add granular subpath exports for tree-shaking
  for (const comp of components) {
    if (comp.category === 'component') {
      exports[`./${comp.name}`] = comp.filePath;
    } else if (comp.category === 'hook') {
      exports[`./hooks/${comp.name}`] = comp.filePath;
    } else if (comp.category === 'lib') {
      exports[`./lib/${comp.name}`] = comp.filePath;
    } else if (comp.category === 'token') {
      exports[`./tokens/${comp.name}`] = comp.filePath;
    }
  }

  return exports;
}

async function updatePackageJson(exports: Record<string, string>) {
  const packageJson = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, 'utf-8'));
  
  packageJson.exports = exports;
  packageJson.sideEffects = false; // Enable tree-shaking
  
  fs.writeFileSync(
    PACKAGE_JSON_PATH,
    JSON.stringify(packageJson, null, 2) + '\n'
  );
  
  console.log(`‚úÖ Updated ${PACKAGE_JSON_PATH}`);
  console.log(`   Generated ${Object.keys(exports).length} subpath exports`);
}

async function generateIndexFile(components: ComponentExport[]) {
  let content = '// Auto-generated by scripts/generate-exports.ts\n';
  content += '// Do not edit manually - run: pnpm gen:exports\n\n';

  // Group by category
  const grouped = components.reduce((acc, comp) => {
    if (!acc[comp.category]) acc[comp.category] = [];
    acc[comp.category].push(comp);
    return acc;
  }, {} as Record<string, ComponentExport[]>);

  // Generate exports by category
  if (grouped.component) {
    content += '// Components\n';
    for (const comp of grouped.component.sort((a, b) => a.name.localeCompare(b.name))) {
      content += `export * from "./components/${comp.name}";\n`;
    }
    content += '\n';
  }

  if (grouped.hook) {
    content += '// Hooks\n';
    for (const comp of grouped.hook.sort((a, b) => a.name.localeCompare(b.name))) {
      content += `export * from "./hooks/${comp.name}";\n`;
    }
    content += '\n';
  }

  if (grouped.lib) {
    content += '// Utilities\n';
    for (const comp of grouped.lib.sort((a, b) => a.name.localeCompare(b.name))) {
      content += `export * from "./lib/${comp.name}";\n`;
    }
    content += '\n';
  }

  if (grouped.token) {
    content += '// Tokens\n';
    for (const comp of grouped.token.sort((a, b) => a.name.localeCompare(b.name))) {
      content += `export * from "./tokens/${comp.name}";\n`;
    }
    content += '\n';
  }

  // Add providers
  content += '// Providers\n';
  content += 'export * from "./providers";\n';

  fs.writeFileSync(INDEX_PATH, content);
  console.log(`‚úÖ Updated ${INDEX_PATH}`);
}

async function main() {
  console.log('üîç Scanning design-system components...');
  
  const components = await scanComponents();
  console.log(`   Found ${components.length} exportable items`);
  
  console.log('\nüì¶ Generating package.json exports...');
  const exports = generatePackageJsonExports(components);
  await updatePackageJson(exports);
  
  console.log('\nüìù Generating index.ts barrel file...');
  await generateIndexFile(components);
  
  console.log('\n‚ú® Export generation complete!');
  console.log('\nüí° Next steps:');
  console.log('   1. Review changes: git diff packages/design-system');
  console.log('   2. Test imports in apps');
  console.log('   3. Commit: git add packages/design-system');
}

main().catch(console.error);
